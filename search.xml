<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[poj1321 棋盘问题]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj1321%2F</url>
    <content type="text"><![CDATA[题意：在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据.每组数据的第一行是两个正整数n k,用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘,以及摆放棋子的数目.n&lt;= 8,k&lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）.Sample Input2 1 # . . # 4 4 . . . # . . # . . # . . # . . .-1 -1Sample Output2112345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n,k;char map[10][10];int vis[10];int ans,cnt;void dfs(int x)&#123; if(cnt==k)&#123; ans++; return ; &#125; if(x&gt;n)return ; for(int i=1;i&lt;=n;++i)&#123; if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;map[x][i]=='#'&amp;&amp;!vis[i])&#123; cnt++;vis[i]=1; dfs(x+1); cnt--;vis[i]=0; &#125; &#125; dfs(x+1); return ;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;k))&#123; if(n==-1||k==-1)&#123; break; &#125; for(int i=1;i&lt;=n;++i) scanf("%s",map[i]+1); memset(vis,0,sizeof(vis)); ans=0,cnt=0; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2612 Find a way]]></title>
    <url>%2F2018%2F11%2F24%2Fhdu2612%2F</url>
    <content type="text"><![CDATA[题目大意：y和m要去肯德基聚餐，图中有多个kfc，他们要选的那个kfc必须到彼此的所用时间之和最小，问 最少需要多少时间（这里一格代表了11分钟）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;using namespace std;const int inf=99999;int n,m;char mp[201][201];int step[201][201][2];int vis[201][201];int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;int flag;struct node&#123;int x,y;&#125;;void bfs(int x,int y)&#123; queue&lt;node &gt;q; node p,tmp;//pair&lt;int,int&gt; p; p.x=x,p.y=y; q.push(p); while(!q.empty())&#123; p=q.front(); q.pop(); //int x=p.x; //int y=p.y; //vis[p.x][p.y]=1; for(int i=0;i&lt;4;++i)&#123; tmp.x=p.x+dir[i][0]; tmp.y=p.y+dir[i][1]; //if(judje(tmp.x,tmp.y)&#123;// if(tmp.x&lt;0||tmp.x&gt;=n||tmp.y&lt;0||tmp.y&gt;=m||vis[tmp.x][tmp.y]||mp[tmp.x][tmp.y]=='#')continue; step[tmp.x][tmp.y][flag]=step[p.x][p.y][flag]+1; q.push(tmp); vis[tmp.x][tmp.y]=1; //&#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; for(int i=0;i&lt;n;++i) scanf("%s",mp[i]); memset(step, inf,sizeof(step));// for(int i=0;i&lt;n;++i)// for(int j=0;j&lt;m;++j)// step[i][j][0]=step[i][j][1]=inf; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) &#123; if(mp[i][j]=='Y')&#123; memset(vis,0,sizeof(vis)); flag=0; step[i][j][flag]=0; bfs(i,j); &#125; if(mp[i][j]=='M')&#123; memset(vis,0,sizeof(vis)); flag=1; step[i][j][flag]=0; bfs(i,j); &#125; &#125; int dis=inf; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j)&#123; if(mp[i][j]=='@'&amp;&amp;dis&gt;step[i][j][0]+step[i][j][1])&#123; dis=step[i][j][0]+step[i][j][1];//dis=min(dis,step[i][j][0]+step[i][j][1]); &#125; &#125; printf("%d\n",dis*11); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>双bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1241 Oil Deposits]]></title>
    <url>%2F2018%2F11%2F24%2Fhdu1241%2F</url>
    <content type="text"><![CDATA[DFS:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;int n,m;char map[110][110];int dir[10][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;,&#123;-1,-1&#125;&#125;;struct node&#123; int x,y; //node(int xx,int yy)&#123;x=xx,y=yy;&#125;&#125;;void dfs(int x,int y)&#123; for(int i=0;i&lt;8;++i)&#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m)continue; if(map[dx][dy]=='@')&#123; map[dx][dy]='*'; dfs(dx,dy); &#125; &#125;&#125;int main()&#123; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; if(n==0||m==0)break; for(int i=1;i&lt;=n;++i) scanf("%s",map[i]+1); int ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]=='@')&#123; map[i][j]='*'; ans++; dfs(i,j); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; BFS:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; typedef long long ll; int n,m; char map[110][110]; int dir[10][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;,&#123;-1,-1&#125;&#125;; struct node&#123; int x,y; //node(int xx,int yy)&#123;x=xx,y=yy;&#125; &#125;; void bfs(int x,int y)&#123; queue&lt;node&gt; q; node point; point.x=x; point.y=y; q.push(point); while(!q.empty()) &#123;//cout&lt;&lt;1&lt;&lt;endl; node cur=q.front();q.pop(); map[cur.x][cur.y]='*'; node tmp;cout&lt;&lt;cur.x&lt;&lt;' '&lt;&lt;cur.y&lt;&lt;' '&lt;&lt;map[cur.x][cur.y]&lt;&lt;endl; for(int i=0;i&lt;8;++i)&#123; int dx=cur.x+dir[i][0]; int dy=cur.y+dir[i][1]; if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m)continue; if(map[dx][dy]=='@')&#123; map[dx][dy]='*'; tmp.x=dx;tmp.y=dy; q.push(tmp); &#125; &#125; &#125; &#125; int main()&#123; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; if(n==0||m==0)break; for(int i=1;i&lt;=n;++i) scanf("%s",map[i]+1); int ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]=='@')&#123; map[i][j]='*'; ans++; bfs(i,j); &#125; &#125; printf("%d\n",ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3984迷宫问题]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3984%2F</url>
    <content type="text"><![CDATA[定义一个二维数组：int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,};它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。Output左上角到右下角的最短路径，格式如样例所示。Sample Input0 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0Sample Output(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4)12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;using namespace std;int mat[5][5];int dir[5][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;struct node&#123;int x,y,pre;&#125;point[100];void dfs(node p)&#123; if(p.pre==-1)&#123;printf("(%d, %d)\n",p.x,p.y);return;&#125; dfs(point[p.pre]); printf("(%d, %d)\n",p.x,p.y);&#125;void bfs()&#123; int x,y,dx,dy,pre=0,cur=1; //queue&lt;node&gt; q; point[0].x=0,point[0].y=0,point[0].pre=-1; mat[0][0]=1; while(pre&lt;=cur)&#123; if(point[pre].x==4&amp;&amp;point[pre].y==4)&#123; dfs(point[pre]); return ; &#125; for(int i=0;i&lt;4;++i)&#123; dx=point[pre].x+dir[i][0]; dy=point[pre].y+dir[i][1]; if(dx&lt;0||dx&gt;=5||dy&lt;0||dy&gt;=5||mat[dx][dy])continue; point[cur].x=dx,point[cur].y=dy,point[cur].pre=pre; ++cur; &#125; ++pre; &#125;&#125;int main()&#123; for(int i=0;i&lt;5;++i) for(int j=0;j&lt;5;++j) scanf("%d",&amp;mat[i][j]); bfs();return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uva11624Fire!]]></title>
    <url>%2F2018%2F11%2F24%2Fuva11624%2F</url>
    <content type="text"><![CDATA[题意：帮助joe走出一个大火蔓延的迷宫，其中joe每分钟可往上下左右四个方向之一走，所有着火的格子都会蔓延（空格与着火格有公共边，下一分钟这个空格也会着火）。迷宫中有一些障碍格，joe和火都无法进入，当joe走到一个边界的格子我们认为他走出了迷宫 输出R行C列的迷宫，#表示墙，.表示空地，J表示joe，F是着火格 如果能走出，输出最少时间否则，impossible感觉很经典的一个问题,在处理每个点着火的时间的时候，却发现假若当前这个点之前已经被火着过一次怎么办了，在一想这就是简单的bfs最优性质决定的，用宽搜的时候就已经保证了在搜索过的着火点已经是最优的了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int maxn=(int)1e3+10;char map[maxn][maxn];int step[maxn][maxn];int vis[maxn][maxn];int n,m;ll inf=0x3f3f3f3f;int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; queue&lt;pair&lt;int,int&gt; &gt;q; void clear(queue&lt;pair&lt;int,int&gt; &gt;&amp; q)&#123; queue&lt;pair&lt;int,int&gt; &gt; empty; swap(empty,q); &#125;void bfs_fire()&#123; while(!q.empty())&#123; pair&lt;int,int&gt; p=q.front(); q.pop(); int x=p.first,y=p.second; // vis[x][y]=1;//vis[p.first][p.second]=1; 如果一直用first second去查找肯定会耗费时间 pair&lt;int,int&gt; tmp; for(int i=0;i&lt;4;++i)&#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m||step[dx][dy]!=inf)continue; if(map[dx][dy]=='#')continue; tmp.first=dx,tmp.second=dy; step[dx][dy]=step[x][y]+1; q.push(tmp); &#125; &#125;&#125;int pe[maxn][maxn];void bfs_person()&#123; pair&lt;int,int &gt; p; while(!q.empty())&#123; p=q.front(); q.pop(); int x=p.first,y=p.second; if(x==1||x==n||y==1||y==m)&#123; printf("%d\n",pe[x][y]+1); return ; &#125; // vis[x][y]=1; for(int i=0;i&lt;4;++i)&#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&lt;1||dx&gt;n||dy&lt;1||dy&gt;m||pe[dx][dy]!=inf)continue; if(map[dx][dy]=='#')continue; if( (pe[x][y]+1&lt;step[dx][dy]) )&#123;//&amp;&amp;step[dx][dy]!=inf wa //加上这个！=inf开始是为了防止更新到障碍物所在的方格，其实上面的！=#已经判断了，不加也可以，不过加上他之后竟然wa掉，那就是说存在数据火到不了的网格人可以到，障碍物把火源包围了的这种情况 pe[dx][dy]=pe[x][y]+1; q.push(make_pair(dx,dy)); &#125; &#125; &#125; printf("IMPOSSIBLE\n");return ;&#125;void solve()&#123; memset(step,inf,sizeof(step)); //memset(vis,0,sizeof(vis)); while(!q.empty())q.pop(); //clear(q); // for(int i=1;i&lt;=n;++i)&#123; // for(int j=1;j&lt;=m;++j) // cout&lt;&lt;map[i][j]; // cout&lt;&lt;endl; // &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]=='F')&#123; step[i][j]=0; q.push(make_pair(i,j)); &#125; &#125; bfs_fire(); // for(int i=1;i&lt;=n;++i)&#123; // for(int j=1;j&lt;=m;++j)&#123; // cout&lt;&lt;step[i][j]&lt;&lt;' '; // &#125; // cout&lt;&lt;endl; // &#125; // memset(vis,0,sizeof(vis)); memset(pe,inf,sizeof(pe)); // clear(q); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]=='J')&#123; pe[i][j]=0; q.push(make_pair(i,j)); break; &#125; &#125; bfs_person(); // for(int i=1;i&lt;=n;++i)&#123; // for(int j=1;j&lt;=m;++j) // cout&lt;&lt;pe[i][j]&lt;&lt;' '; // cout&lt;&lt;endl; // &#125; //return;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; scanf("%s",(map[i]+1)); &#125; solve(); &#125; return 0;&#125;//除了上面的那个inf问题还有就是开始定义了两个vis的初始化，一开始就T掉，]]></content>
      <categories>
        <category>搜索</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3414Pots]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3414%2F</url>
    <content type="text"><![CDATA[给出两个壶的容量A和B, 一个目标水量C，对A、B可以有３种操作，求最少经过几步操作能够在某个壶中得到目标水量C。输入A、B和C，输入最少操作数和操作过程。这道题和上一道搜索题目(hdu1495)的建模是几乎一样,要说不一样的,也没啥不一样的了 .需要记录最短路径那道题是有三个杯子可以相互作为中间态，一种有六种状态进行到水,这个虽然只有2个杯子，一个理论的状态量，但限制了给定3种倒水策略所以还是6中方式(太麻烦了，bfs都这么长123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;queue&gt;using namespace std;const int inf=0x3f3f3f3f;const int maxn=105;int vis[maxn][maxn];int n,m,enen;struct node&#123;int x,y;int step;char path[maxn];int cnt;&#125;;string path[] = &#123;"FILL(1)","FILL(2)","DROP(1)","DROP(2)","POUR(1,2)","POUR(2,1)"&#125;;void work(int step,char pa[],int cnt)&#123; printf("%d\n",step); for(int i=0;i&lt;cnt;++i) cout&lt;&lt;path[pa[i]]&lt;&lt;endl; &#125;void bfs()&#123; queue&lt;node&gt;q; memset(vis,0,sizeof(vis)); node p,tmp; p.x=0,p.y=0,p.step=0,p.cnt=0; vis[0][0]=1; q.push(p); while(!q.empty())&#123; p=q.front(); q.pop(); // cout&lt;&lt;p.x&lt;&lt;' '&lt;&lt;p.y&lt;&lt;endl; if(p.x==enen||p.y==enen)&#123; work(p.step,p.path,p.cnt); return ; &#125; tmp=p; tmp.step++; tmp.cnt++; //FILL(n) if(n&gt;p.x)&#123; tmp.x=n; tmp.y=p.y; if(!vis[tmp.x][tmp.y])&#123; tmp.path[p.cnt]=0; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; //Fill(m) if(m&gt;p.y)&#123; tmp.x=p.x; tmp.y=m; if(!vis[tmp.x][tmp.y])&#123; tmp.path[p.cnt]=1; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; //DROP(n) if(p.x)&#123; tmp.x=0,tmp.y=p.y; if(!vis[tmp.x][tmp.y])&#123; tmp.path[p.cnt]=2; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; //DROP(m) if(p.y)&#123; tmp.x=p.x; tmp.y=0; if(!vis[tmp.x][tmp.y]) &#123; tmp.path[p.cnt]=3; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; //POUR(n,m) if(p.x&amp;&amp;(p.y&lt;m))&#123; if(p.x&gt;(m-p.y))&#123; tmp.x=p.x-(m-p.y); tmp.y=m; &#125; else&#123; tmp.x=0; tmp.y=p.y+p.x; &#125; if(!vis[tmp.x][tmp.y])&#123; tmp.path[p.cnt]=4; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; //POUR(m,n) if(p.y&amp;&amp;(p.x&lt;n))&#123; if(p.y&gt;(n-p.x))&#123; tmp.x=n; tmp.y=p.y-(n-p.x); &#125; else&#123; tmp.x=p.x+p.y; tmp.y=0; &#125; if(!vis[tmp.x][tmp.y]) &#123; tmp.path[p.cnt]=5; q.push(tmp); vis[tmp.x][tmp.y]=1; &#125; &#125; &#125; printf("impossible\n");&#125;int main()&#123; while(scanf("%d%d%d",&amp;n,&amp;m,&amp;enen)!=EOF)&#123; bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索,数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1495非常可乐]]></title>
    <url>%2F2018%2F11%2F24%2Fhdu1495%2F</url>
    <content type="text"><![CDATA[大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束Output如果能平分的话请输出最少要倒的次数，否则输出”NO”Sample Input7 4 34 1 30 0 0Sample OutputNO3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//用bfs模拟6种情况来写的，麻烦到爆炸#include &lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;int s,n,m;struct node&#123; int s,n,m,step;&#125;;int vis[105][105][105];void bfs()&#123; if(s%2==1)&#123;printf("NO\n");return;&#125; memset(vis,0,sizeof(vis)); node point; point.s=s, point.n=0, point.m=0, point.step=0; queue&lt;node&gt;q; q.push(point); vis[point.s][point.n][point.m]=1; while(!q.empty())&#123; node p=q.front(); q.pop(); node tmp; if((p.s==p.n&amp;&amp;p.s==s/2)||(p.s==p.m&amp;&amp;p.s==s/2)||(p.n==p.m&amp;&amp;p.n==s/2))&#123; printf("%d\n",p.step); return ; &#125; // s--&gt;n if(p.s&amp;&amp;(n&gt;p.n))&#123; if(p.s&gt;n-p.n)&#123; tmp.s=p.s-(n-p.n); tmp.n=n; tmp.m=p.m; &#125; else&#123; tmp.s=0; tmp.n=p.n+p.s; tmp.m=p.m; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; //s--&gt;m if(p.s&amp;&amp;m&gt;p.m)&#123; if(p.s&gt;m-p.m)&#123; tmp.s=p.s-(m-p.m); tmp.n=p.n; tmp.m=m; &#125; else&#123; tmp.s=0; tmp.n=p.n; tmp.m=p.m+p.s; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; // n--&gt;s if(p.n&amp;&amp;s&gt;p.s)&#123; if(p.n&gt;s-p.s)&#123; tmp.s=s; tmp.n=p.n-(s-p.s); tmp.m=p.m; &#125; else&#123; tmp.s=p.s+p.n; tmp.n=0; tmp.m=p.m; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; // n--&gt;m if(p.n&amp;&amp;m&gt;p.m)&#123; if(p.n&gt;m-p.m)&#123; tmp.s=p.s; tmp.n=p.n-(m-p.m); tmp.m=m; &#125; else&#123; tmp.s=p.s; tmp.n=0; tmp.m=p.m+p.n; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; // m--&gt;s if(p.m&amp;&amp;s&gt;p.s)&#123; if(p.m&gt;s-p.s)&#123; tmp.s=s; tmp.n=p.n; tmp.m=p.m-(s-p.s); &#125;else&#123; tmp.s=p.s+p.m; tmp.n=p.n; tmp.m=0; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; // m--&gt;n if(p.m&amp;&amp;n&gt;p.n)&#123; if(p.m&gt;n-p.n)&#123; tmp.s=p.s; tmp.n=n; tmp.m=p.m-(n-p.n); &#125;else&#123; tmp.s=p.s; tmp.n=p.n+p.m; tmp.m=0; &#125; if(!vis[tmp.s][tmp.n][tmp.m])&#123; vis[tmp.s][tmp.n][tmp.m]=1; tmp.step=p.step+1; q.push(tmp); &#125; &#125; &#125; printf("NO\n");return;&#125;int main()&#123; while(scanf("%d%d%d",&amp;s,&amp;n,&amp;m)!=EOF)&#123; if(s+n+m==0)break; bfs(); &#125; return 0;&#125; 开始看到就是一个数学思想，结果没有推出来12345678910111213141516171819202122232425262728#include &lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; typedef long long ll; int gcd(int a,int b)&#123; if(a%b==0) return b; return gcd(b,a%b); &#125; int main()&#123; int s,n,m; while(scanf("%d%d%d",&amp;s,&amp;n,&amp;m)!=EOF)&#123; if(s+n+m==0)break; if(s&amp;1)&#123;printf("NO\n");continue;&#125; int d=gcd(n,m); //if(s%d)&#123;printf("NO\n");continue;&#125; d=gcd(s,d); if((s/d)&amp;1) &#123;printf("NO\n");continue;&#125; else &#123; printf("%d\n",s/d-1); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3087Shuffle'm Up]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3087%2F</url>
    <content type="text"><![CDATA[已知两堆牌s1和s2的初始状态， 其牌数均为c，按给定规则能将他们相互交叉组合成一堆牌s12，再将s12的最底下的c块牌归为s1，最顶的c块牌归为s2，依此循环下去。现在输入s1和s2的初始状态 以及 预想的最终状态s12问s1 s2经过多少次洗牌之后，最终能达到状态s12，若永远不可能相同，则输出”-1”。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;int ans,n;map&lt;string,int&gt;m;char s1[200],s2[200],s3[200];void dfs(char s[],int step)&#123; if((ans=-1&amp;&amp;step&gt;=ans)||m[s])return; if(m[s])return; if(!strcmp(s,s3))&#123;ans=step;return ;&#125; m[s]=true; char ss[200]=""; int op=0; for(int i=0;i&lt;n;++i) &#123; ss[op++]=s[i+n]; ss[op++]=s[i]; &#125; dfs(ss,step+1);&#125;int main()&#123; int t; char ss[200]; scanf("%d",&amp;t); for(int ca=1;ca&lt;=t;++ca)&#123; ans=-1; m.clear();// map&lt;&gt; scanf("%d",&amp;n); scanf("%s",s1); scanf("%s",s2); scanf("%s",ss); char s[200]; int op=0; for(int i=0;i&lt;n;++i)&#123; s[op++]=s1[i]; s[op++]=s2[i]; &#125; dfs(s,1); printf("%d %d\n",ca,ans); &#125;&#125; 模拟：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int t; scanf("%d",&amp;t); for(int ca=1;ca&lt;=t;++ca)&#123; int n; char s1[1005],s2[1005],en[10000]; map&lt;string,bool &gt;m; scanf("%d",&amp;n); scanf("%s",s1); scanf("%s",s2); scanf("%s",en); int step=0; int times=1000,ti=0; while(true)&#123; ti++; char s[1000]; int pc=0; for(int i=0;i&lt;n;++i)&#123; s[pc++]=s2[i]; s[pc++]=s1[i]; &#125; s[pc]='\0'; step++; if(!strcmp(s,en))&#123; printf("%d %d\n",ca,step); break; &#125; if(m[s])&#123; printf("%d %d\n",ca,-1); break; &#125; m[s]=true; strncpy(s1,s,n); s1[n]='\0'; strncpy(s2,s+n,n); s2[n]='\0'; if(ti==times)&#123; printf("%d %d\n",ca,-1); break; &#125; &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>搜索,模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3126Prime Path]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3126%2F</url>
    <content type="text"><![CDATA[给定两个四位素数a b，要求把a变换到b变换的过程要 每次变换出来的数都是一个 四位素数，而且当前这步的变换所得的素数 与 前一步得到的素数 只能有一个位不同，而且每步得到的素数都不能重复。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;queue&gt;using namespace std;const int maxn=2e5;bool a[maxn];bool prime[maxn];bool vis[maxn];int step[maxn];int n,m;int cnt=0;//四位数的素数也就有1061个void getprime()&#123; memset(a,false,sizeof(a)); memset(prime,false,sizeof(prime)); for(int i=2; i&lt;10000; ++i)&#123; if(!a[i])&#123; if(i&gt;=1000) prime[i]=true; for(int j=i*i; j&lt;10000; j+=i) a[j]=true; &#125; &#125;&#125;//将number的倒数第pos位置变为valint get(int num,int pos,int val)&#123; switch(pos)&#123; case 0:return num/10*10+val; case 1:return num/100*100+val*10+num%10; case 2:return num/1000*1000+val*100+num%100; case 3:return val*1000+num%1000; &#125;&#125;void bfs()&#123; memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; q.push(m); vis[m]=1; step[m]=0; int k=0; while(!q.empty())&#123; int p=q.front(); q.pop(); if(p==n)&#123; printf("%d\n",step[p]); return ; &#125; for(int i=0; i&lt;=9; ++i)&#123; for( k=0; k&lt;4; ++k)&#123; //if(k==3&amp;&amp;i==0) continue; int tmp=get(p,k,i); if(prime[tmp]&amp;&amp;!vis[tmp])&#123; q.push(tmp); step[tmp]=step[p]+1; vis[tmp]=true; &#125; &#125; &#125; &#125; printf("Impossible\n");&#125;int main()&#123; int t; getprime(); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;m,&amp;n); bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1426Find The Multiple]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj1426%2F</url>
    <content type="text"><![CDATA[给一个数n，让你找出一个只有1，0，组成的十进制数，要求是找到的数可以被n整除。123456789101112131415161718192021222324252627282930313233343536373839 #include &lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int maxn=1e6+10; int n;void bfs()&#123; queue&lt;ll&gt; q; ll tmp; q.push(1); while(!q.empty())&#123; tmp=q.front(); q.pop(); if(tmp%n==0) &#123; printf("%lld\n",tmp); return ; &#125; q.push(tmp*10); q.push(tmp*10+1); &#125;&#125;int main()&#123; while(scanf("%d",&amp;n)!=EOF)&#123; if(n==0)break; bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3279]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3279%2F</url>
    <content type="text"><![CDATA[题意：有一个n*m的格子，每个格子都有黑白两面（0表示白色，1表示黑色）。我们需要把所有的格子都反转成黑色，每反转一个格子，它上下左右的格子都会跟着反转。请求出用最小步数完成反转时每个格子反转的次数。有多个解时，输出字典序最小的一组。 下面引自挑战内容：首先，同一个格子翻转两次的话就会恢复原状，所以多次翻转是多余的。此外，翻转的格子的集 合相同的话，其次序是无关紧要的。因此，总共有2NM种翻转的方法。不过这个解空间太大了， 我们需要想出更有效的办法。 不妨先看看左上角的格子。在这里，除了翻转(1,1)之外，翻转(1,2)和(2,1)也可以把这个格子翻 转。 于是不妨先指定好上面一行的翻转方法。此时能够翻转(1,1)的只剩下(2,1)了，所以可以直接判 断(2,1)是否需要翻转。类似地(2,1)~(2,N)都能这样判断，如此反复下去就可以确定所有格子的翻 转方法。后(M,1)~(M,N)如果并非全为白色，就意味着不存在可行的操作方法。 像这样，先确定第一行的翻转方式，然后可以很容易判断这样是否存在解以及解的小步数是多 少，这样将第一行的所有翻转方式都尝试一次就能求出整个问题的小步数。这个算法中上面 一行的翻转方式共有2N种，复杂度为O(MN2N)。–引自：《挑战》 模型建立: 0.也就是说除了最后一行，上面的所有行的颜色状态都可以由 在上面的一行的状态进行确定（即0-(n-1)行之间的反转来把他确定位0的状态，第n行在这个时候就直接判断是否都为0的状态，是的话就是有效解，然后在取相对优的解） 1. 第一行的状态咱们又可以通过枚举子集来进行找出所有的情况，那么下面的所有行就可以通过迭代以及是否反转 来确定状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;stdlib.h&gt;using namespace std;const int inf=0x3f3f3f3f;int n,m;int state[25][25];int en[25][25];int flip[25][25];int dir[5][2]=&#123;&#123;0,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;int get(int x,int y)&#123; int cnt=state[x][y]; for(int i=0;i&lt;5;++i) &#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m)continue; cnt+=flip[dx][dy]; &#125; return cnt&amp;1;&#125;int clca()&#123; for(int i=1;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; if(get(i-1,j)) flip[i][j]=1; &#125; &#125; for(int i=0;i&lt;m;++i)&#123; if(get(n-1,i)) return -1; &#125; int tmp=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) tmp+=flip[i][j]; return tmp;&#125;void solve()&#123; int ans=-1; //二进制的状态压缩过程,对这道题来讲就是对flip[0]的每一个状态位,都枚举一遍, //只要抓住 移位，设置标志位 两个要素也没有那么难. for(int i=0;i&lt;1&lt;&lt;m;++i)&#123; memset(flip,0,sizeof(flip)); for(int j=0;j&lt;m;++j)&#123; flip[0][j]=i&gt;&gt;j&amp;1; &#125; int cnt=clca();//然后这儿进行判断是解的优劣情况 if(cnt&gt;=0&amp;&amp;(ans&lt;0||ans&gt;cnt))&#123; ans=cnt; memcpy(en,flip,sizeof(flip)); &#125; &#125; if(ans&lt;0)&#123; printf("IMPOSSIBLE\n"); return ; &#125; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) printf("%d%c",en[i][j],j+1==m?'\n':' '); //printf("%d\n",ans);&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) scanf("%d",&amp;state[i][j]); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>开关问题</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>开关问题 状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3278 Catch That Cow]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj3278%2F</url>
    <content type="text"><![CDATA[FJ要抓奶牛。 开始输入N（FJ的位置）K（奶牛的位置）。FJ有三种移动方法：1、向前走一步，耗时一分钟。 2、向后走一步，耗时一分钟。 3、向前移动到当前位置的两倍N*2，耗时一分钟。问FJ抓到奶牛的最少时间。奶牛不会动。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=100001;bool vis[maxn];int step[maxn];void bfs(int n,int k)&#123; memset(step,0,sizeof(step)); memset(vis,false,sizeof(vis)); queue &lt;int&gt; q; int p,tmp; q.push(n); step[n]=0; vis[n]=true; while(!q.empty()) &#123; p=q.front(); q.pop(); if(p==k)&#123;printf("%d\n",step[p]);return ;&#125; for(int i=0;i&lt;3;i++) &#123; if(i==0) tmp=p-1; else if(i==1) tmp=p+1; else tmp=p*2; if(tmp&lt;0 || tmp&gt;=maxn) continue; if(!vis[tmp]) &#123; q.push(tmp); step[tmp]=step[p]+1; vis[tmp]=true; &#125; &#125; &#125;&#125;int main()&#123; int n,k; while(scanf("%d%d",&amp;n,&amp;k)!=EOF)&#123; if(n&gt;=k) printf("%d\n",n-k); else bfs(n,k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2251 Dungeon Master]]></title>
    <url>%2F2018%2F11%2F24%2Fpoj2251%2F</url>
    <content type="text"><![CDATA[题目大意：给一个三维图，可以前后左右上下6种走法，走一步1分钟，求最少时间（其实就是最短路）分析：DFS的话复杂度为O(6^n)会TLE）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;char map[35][35][35];int vis[35][35][35];int X,Y,Z,sx,sy,sz,ex,ey,ez;int dir[6][3] = &#123;&#123;0,0,1&#125;,&#123;0,0,-1&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;1,0,0&#125;,&#123;-1,0,0&#125;&#125;; int step[35][35][35];struct node&#123; int x,y,z;&#125;;int bfs()&#123; node p,next; queue&lt;node&gt; Q; p.x = sx,p.y = sy,p.z = sz; step[sx][sy][sz]=0; vis[sx][sy][sz] = 1; Q.push(p); while(!Q.empty())&#123; p = Q.front(); Q.pop(); if(map[p.x][p.y][p.z]=='E') return step[ex][ey][ez];//p.step; vis[p.x][p.y][p.z]=1; for(int i = 0; i&lt;6; i++) &#123; int dx = p.x+dir[i][0]; int dy = p.y+dir[i][1]; int dz = p.z+dir[i][2]; //if(check(next.x,next.y,next.z)) if(vis[dx][dy][dz]||map[dx][dy][dz]=='#'||dx&lt;0||dx&gt;=X||dy&lt;0||dy&gt;=Y||dz&lt;0||dz&gt;=Z) continue; vis[dx][dy][dz] = 1; next.x=dx,next.y=dy,next.z=dz; step[dx][dy][dz]=step[p.x][p.y][p.z]+1;//next.step = p.step+1; Q.push(next); &#125; &#125; return 0;&#125;int main()&#123; int i,j,r; while(scanf("%d%d%d",&amp;X,&amp;Y,&amp;Z),X+Y+Z) &#123; for(i = 0; i&lt;X; i++) &#123; for(j = 0; j&lt;Y; j++) &#123; scanf("%s",map[i][j]); for(r = 0; r&lt;Z; r++) &#123; if(map[i][j][r] == 'S') &#123; sx = i,sy = j,sz = r; &#125; else if(map[i][j][r] == 'E') &#123; ex = i,ey = j,ez = r; &#125; &#125; &#125; &#125; memset(vis,0,sizeof(vis)); int ans; ans = bfs(); if(ans) printf("Escaped in %d minute(s).\n",ans); else printf("Trapped!\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-0]]></title>
    <url>%2F2018%2F11%2F06%2Ftext-0%2F</url>
    <content type="text"><![CDATA[d L; ,.’’/12 https://www.csdn.net32222233333456789101112131415123456#include&lt;stdio.h&gt; int maim() &#123; cout&lt;&lt;"sxy"&lt;&lt;endl; return 0; &#125; 1617181920222324252627282930end]]></content>
      <categories>
        <category>haha</category>
        <category>Ha</category>
      </categories>
      <tags>
        <tag>-HH --H</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
